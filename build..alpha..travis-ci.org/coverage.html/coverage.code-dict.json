{"/home/travis/build/npmtest/node-npmtest-memcached/test.js":"/* istanbul instrument in package npmtest_memcached */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-memcached/lib.npmtest_memcached.js":"/* istanbul instrument in package npmtest_memcached */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_memcached = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_memcached = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-memcached/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-memcached && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_memcached */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_memcached\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_memcached.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_memcached.rollup.js'] =\n            local.assetsDict['/assets.npmtest_memcached.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_memcached.__dirname +\n                    '/lib.npmtest_memcached.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-memcached/memcached/index.js":"module.exports = require('./lib/memcached.js');","/home/travis/build/npmtest/node-npmtest-memcached/memcached/lib/memcached.js":"\"use strict\";\n\n/**\n * Node's native modules\n */\nvar Stream = require('net').Stream\n  , Socket = require('net').Socket;\n\n/**\n * External or custom modules\n */\nvar HashRing = require('hashring')\n  , Connection = require('./connection')\n  , Jackpot = require('jackpot')\n  , Utils = require('./utils')\n  , IssueLog = Connection.IssueLog;\n\n/**\n * Variable lookups\n */\nvar curry = Utils.curry;\n\n/**\n * Constructs a new memcached client\n *\n * @constructor\n * @param {Mixed} args Array, string or object with servers\n * @param {Object} options options\n * @api public\n */\nfunction Client (args, options) {\n  var servers = []\n    , weights = {}\n    , regular = 'localhost:11211'\n    , key;\n\n  // Parse down the connection arguments\n  switch (Object.prototype.toString.call(args)) {\n    case '[object Object]':\n      weights = args;\n      servers = Object.keys(args);\n      break;\n\n    case '[object Array]':\n      servers = args.length ? args : [regular];\n      break;\n\n    default:\n      servers.push(args || regular);\n      break;\n  }\n\n  if (!servers.length) {\n    throw new Error('No servers where supplied in the arguments');\n  }\n\n  // merge with global and user config\n  Utils.merge(this, Client.config);\n  Utils.merge(this, options);\n\n  this.servers = servers;\n  var compatibility = this.compatibility || this.compatiblity;\n  this.HashRing = new HashRing(args, this.algorithm, {\n    'compatibility': compatibility,\n    'default port': compatibility === 'ketama' ? 11211 : null\n  });\n  this.connections = {};\n  this.issues = [];\n}\n\n// Allows users to configure the memcached globally or per memcached client\nClient.config = {\n    maxKeySize: 250         // max key size allowed by Memcached\n  , maxExpiration: 2592000  // max expiration duration allowed by Memcached\n  , maxValue: 1048576       // max length of value allowed by Memcached\n  , activeQueries: 0\n  , maxQueueSize: -1\n  , algorithm: 'md5'        // hashing algorithm that is used for key mapping\n  , compatibility: 'ketama' // hashring compatibility\n\n  , poolSize: 10            // maximal parallel connections\n  , retries: 5              // Connection pool retries to pull connection from pool\n  , factor: 3               // Connection pool retry exponential backoff factor\n  , minTimeout: 1000        // Connection pool retry min delay before retrying\n  , maxTimeout: 60000       // Connection pool retry max delay before retrying\n  , randomize: false        // Connection pool retry timeout randomization\n\n  , reconnect: 18000000     // if dead, attempt reconnect each xx ms\n  , timeout: 5000           // after x ms the server should send a timeout if we can't connect\n  , failures: 5             // Number of times a server can have an issue before marked dead\n  , failuresTimeout: 300000   // Time after which `failures` will be reset to original value, since last failure\n  , retry: 30000            // When a server has an error, wait this amount of time before retrying\n  , idle: 5000              // Remove connection from pool when no I/O after `idle` ms\n  , remove: false           // remove server if dead if false, we will attempt to reconnect\n  , redundancy: false       // allows you do re-distribute the keys over a x amount of servers\n  , keyCompression: true    // compress keys if they are to large (md5)\n  , namespace: ''           // sentinel to prepend to all memcache keys for namespacing the entries\n  , debug: false            // Output the commands and responses\n};\n\n// There some functions we don't want users to touch so we scope them\n(function (nMemcached) {\n  var LINEBREAK = '\\r\\n'\n    , NOREPLY = ' noreply'\n    , FLUSH = 1E3\n    , BUFFER = 1E2\n    , CONTINUE = 1E1\n    , FLAG_JSON = 1<<1\n    , FLAG_BINARY = 1<<2\n    , FLAG_NUMERIC = 1<<3;\n\n  nMemcached.prototype.__proto__ = require('events').EventEmitter.prototype;\n\n  var memcached = nMemcached.prototype\n    , privates = {}\n    , undefined;\n\n  // Creates or generates a new connection for the give server, the callback\n  // will receive the connection if the operation was successful\n  memcached.connect = function connect(server, callback) {\n    // Default port to 11211\n    if(!server.match(/(.+):(\\d+)$/)) {\n        server = server + ':11211';\n    }\n\n    // server is dead, bail out\n    if (server in this.issues && this.issues[server].failed) {\n        return callback(false, false);\n    }\n\n    // fetch from connection pool\n    if (server in this.connections) {\n      return this.connections[server].pull(callback);\n    }\n\n    // No connection factory created yet, so we must build one\n    var serverTokens = server[0] === '/'\n        ? server\n        : /(.*):(\\d+){1,}$/.exec(server).reverse()\n      , memcached = this;\n\n    // Pop original string from array\n    if (Array.isArray(serverTokens)) serverTokens.pop();\n\n    var sid = 0\n      , manager;\n\n    /**\n     * Generate a new connection pool manager.\n     */\n\n    manager = new Jackpot(this.poolSize);\n    manager.retries = memcached.retries;\n    manager.factor = memcached.factor;\n    manager.minTimeout = memcached.minTimeout;\n    manager.maxTimeout = memcached.maxTimeout;\n    manager.randomize = memcached.randomize;\n\n    manager.setMaxListeners(0);\n\n    manager.factory(function factory() {\n      var S = Array.isArray(serverTokens)\n          ? new Stream\n          : new Socket\n        , Manager = this\n        , idleTimeout = function() {\n            Manager.remove(this);\n          }\n        , streamError = function(e) {\n            memcached.connectionIssue(e.toString(), S);\n            Manager.remove(this);\n        };\n\n      // config the Stream\n      S.streamID = sid++;\n      S.setTimeout(memcached.timeout);\n      S.setNoDelay(true);\n      S.setEncoding('utf8');\n      S.metaData = [];\n      S.responseBuffer = \"\";\n      S.bufferArray = [];\n      S.serverAddress = server;\n      S.tokens = [].concat(serverTokens);\n      S.memcached = memcached;\n\n      // Add the event listeners\n      Utils.fuse(S, {\n          close: function streamClose() {\n            Manager.remove(this);\n          }\n        , data: curry(memcached, privates.buffer, S)\n        , connect: function streamConnect() {\n            // Jackpot handles any pre-connect timeouts by calling back\n            // with the error object.\n            this.setTimeout(this.memcached.idle, idleTimeout);\n            // Jackpot handles any pre-connect errors, but does not handle errors\n            // once a connection has been made, nor does Jackpot handle releasing\n            // connections if an error occurs post-connect\n            this.on('error', streamError);\n          }\n        , end: S.end\n      });\n\n      // connect the net.Stream (or net.Socket) [port, hostname]\n      S.connect.apply(S, S.tokens);\n      return S;\n    });\n\n    manager.on('error', function err(e) {\n      if (memcached.debug) console.log('Connection error', e);\n    });\n\n    this.connections[server] = manager;\n\n    // now that we have setup our connection factory we can allocate a new\n    // connection\n    this.connections[server].pull(callback);\n  };\n\n  // Exposes buffer to test-suite\n  memcached.buffer = function buffer() {\n    return privates.buffer.apply(this, arguments);\n  };\n\n  // Creates a multi stream, so it's easier to query agains multiple memcached\n  // servers.\n  memcached.multi = function memcachedMulti(keys, callback) {\n    var map = {}\n      , memcached = this\n      , servers\n      , i;\n\n    // gets all servers based on the supplied keys,\n    // or just gives all servers if we don't have keys\n    if (keys) {\n      keys.forEach(function fetchMultipleServers(key) {\n        var server = memcached.servers.length === 1\n          ? memcached.servers[0]\n          : memcached.HashRing.get(key);\n\n        if (map[server]){\n          map[server].push(key);\n        } else {\n          map[server] = [key];\n        }\n      });\n\n      // store the servers\n      servers = Object.keys(map);\n    } else {\n      servers = this.servers;\n    }\n\n    i = servers.length;\n\n    while (i--) {\n       //memcached.delegateCallback(this, servers[i], map[servers[i]], i, servers.length, callback);\n      callback.call(this, servers[i], map[servers[i]], i, servers.length);\n    }\n  };\n\n  // Executes the command on the net.Stream, if no server is supplied it will\n  // use the query.key to get the server from the HashRing\n  memcached.command = function memcachedCommand(queryCompiler, server) {\n\n      this.activeQueries++;\n      var query = queryCompiler();\n\n      if (this.activeQueries> this.maxQueueSize && this.maxQueueSize > 0){\n          this.makeCallback(query.callback, \"over queue limit\", null);\n          query = null;\n          return;\n      }\n\n      // generate a regular query,\n      var redundancy = this.redundancy && this.redundancy < this.servers.length\n      , queryRedundancy = query.redundancyEnabled\n      , memcached = this;\n\n    // validate the arguments\n    if (query.validate && !Utils.validateArg(query, this)) {\n        this.activeQueries--;\n        return;\n    }\n\n    // try to find the correct server for this query\n    if (!server) {\n      // no need to do a hashring lookup if we only have one server assigned to\n      // us\n      if (this.servers.length === 1) {\n        server = this.servers[0];\n      } else {\n        if (redundancy && queryRedundancy) {\n          redundancy = this.HashRing.createRange(query.key, (this.redundancy + 1), true);\n          server = redundancy.shift();\n        } else {\n          server = this.HashRing.get(query.key);\n        }\n      }\n    }\n\n    // check if any server exists or and if the server is still alive\n    // a server may not exist if the manager was never able to connect\n    // to any server.\n    if (!server || (server in this.issues && this.issues[server].failed)) {\n      return query.callback && memcached.makeCallback(query.callback,new Error(['Server at', server, 'not available'].join(' ')));\n    }\n\n    this.connect(server, function allocateMemcachedConnection(error, S) {\n      if (memcached.debug) {\n        query.command.split(LINEBREAK).forEach(function errors(line) {\n          console.log(S.streamID + ' << ' + line);\n        });\n      }\n\n      // S not set if unable to connect to server\n      if (!S) {\n        var S = {\n          serverAddress: server,\n          tokens: server.split(':').reverse()\n        }\n        var message = error || 'Unable to connect to server';\n        memcached.connectionIssue(message, S);\n        return query.callback && memcached.makeCallback(query.callback,new Error(message));\n\n      }\n\n      // Other errors besides inability to connect to server\n      if (error) {\n        memcached.connectionIssue(error.toString(), S);\n        return query.callback && memcached.makeCallback(query.callback,error);\n      }\n\n      if (S.readyState !== 'open') {\n        var message = 'Connection readyState is set to ' + S.readyState;\n        memcached.connectionIssue(message, S);\n        return query.callback && memcached.makeCallback(query.callback,new Error(message));\n      }\n\n      // used for request timing\n      query.start = Date.now();\n      S.metaData.push(query);\n      S.write(Utils.reallocString(query.command + LINEBREAK));\n    });\n\n    // if we have redundancy enabled and the query is used for redundancy, than\n    // we are going loop over the servers, check if we can reach them, and\n    // connect to the correct net connection. because all redundancy queries are\n    // executed with \"no reply\" we do not need to store the callback as there\n    // will be no value to parse.\n    if (redundancy && queryRedundancy) {\n      queryRedundancy = queryCompiler(queryRedundancy);\n\n      redundancy.forEach(function each(server) {\n        if (server in memcached.issues && memcached.issues[server].failed){\n            return;\n        }\n\n        memcached.connect(server, function allocateMemcachedConnection(error, S) {\n          if (!S || error || S.readyState !== 'open') return;\n          S.write(queryRedundancy.command + LINEBREAK);\n        });\n      });\n    }\n  };\n\n  // Logs all connection issues, and handles them off. Marking all requests as\n  // cache misses.\n  memcached.connectionIssue = function connectionIssue(error, S) {\n    if (S && S.end) S.end();\n\n    var issues\n      , server = S.serverAddress\n      , memcached = this;\n\n    // check for existing issue logs, or create a new log\n    if (server in this.issues) {\n      issues = this.issues[server];\n    } else {\n      issues = this.issues[server] = new IssueLog({\n          server: server\n        , tokens: S.tokens\n        , reconnect: this.reconnect\n        , failures: this.failures\n        , failuresTimeout: this.failuresTimeout\n        , retry: this.retry\n        , remove: this.remove\n        , failOverServers: this.failOverServers || null\n      });\n\n      // proxy the events\n      Utils.fuse(issues, {\n          issue: function issue(details) {\n            memcached.emit('issue', details);\n          }\n        , failure: function failure(details) {\n            memcached.emit('failure', details);\n          }\n        , reconnecting: function reconnect(details) {\n            memcached.emit('reconnecting', details);\n          }\n        , reconnected: function reconnected(details) {\n            memcached.emit('reconnect', details);\n          }\n        , remove: function remove(details) {\n            // emit event and remove servers\n            memcached.emit('remove', details);\n            memcached.connections[server].end();\n\n            if (this.failOverServers && this.failOverServers.length) {\n              memcached.HashRing.swap(server, this.failOverServers.shift());\n            } else {\n              memcached.HashRing.remove(server);\n              memcached.emit('failure', details);\n            }\n          }\n      });\n\n      // bumpt the event listener limit\n      issues.setMaxListeners(0);\n    }\n\n    // log the issue\n    issues.log(error);\n  };\n\n  // Kills all active connections\n  memcached.end = function endMemcached() {\n    var memcached = this;\n\n    Object.keys(this.connections).forEach(function closeConnection(key) {\n      memcached.connections[key].free(0);\n    });\n  };\n\n  // These do not need to be publicly available as it's one of the most important\n  // parts of the whole client, the parser commands:\n  privates.parsers = {\n    // handle error responses\n    'NOT_FOUND': function notfound(tokens, dataSet, err) {\n      return [CONTINUE, false];\n    }\n\n  , 'NOT_STORED': function notstored(tokens, dataSet, err) {\n      var errObj = new Error('Item is not stored');\n      errObj.notStored = true;\n      err.push(errObj);\n      return [CONTINUE, false];\n    }\n\n  , 'ERROR': function error(tokens, dataSet, err) {\n      err.push(new Error('Received an ERROR response'));\n      return [FLUSH, false];\n    }\n\n  , 'CLIENT_ERROR': function clienterror(tokens, dataSet, err) {\n      err.push(new Error(tokens.splice(1).join(' ')));\n      return [CONTINUE, false];\n    }\n\n  , 'SERVER_ERROR': function servererror(tokens, dataSet, err, queue, S, memcached) {\n      (memcached || this.memcached).connectionIssue(tokens.splice(1).join(' '), this);\n      return [CONTINUE, false];\n    }\n\n    // keyword based responses\n  , 'STORED': function stored(tokens, dataSet) {\n      return [CONTINUE, true];\n    }\n\n  , 'TOUCHED': function touched(tokens, dataSet) {\n        return [CONTINUE, true];\n    }\n\n  , 'DELETED': function deleted(tokens, dataSet) {\n      return [CONTINUE, true];\n    }\n\n  , 'OK': function ok(tokens, dataSet) {\n      return [CONTINUE, true];\n    }\n\n  , 'EXISTS': function exists(tokens, dataSet) {\n      return [CONTINUE, false];\n    }\n\n  , 'END': function end(tokens, dataSet, err, queue) {\n      if (!queue.length) queue.push(undefined);\n      return [FLUSH, true];\n    }\n\n    // value parsing:\n  , 'VALUE': function value(tokens, dataSet, err, queue) {\n      var key = tokens[1]\n        , flag = +tokens[2]\n        , dataLen = tokens[3] // length of dataSet in raw bytes\n        , cas = tokens[4]\n        , multi = this.metaData[0] && this.metaData[0].multi || cas\n          ? {}\n          : false\n        , tmp;\n\n      // In parse data there is an '||' passing us the content of token\n      // if dataSet is empty. This may be fine for other types of responses,\n      // in the case of an empty string being stored in a key, it will\n      // result in unexpected behavior:\n      // https://github.com/3rd-Eden/node-memcached/issues/64\n      if (dataLen === '0') {\n        dataSet = '';\n      }\n\n      switch (flag) {\n        case FLAG_JSON:\n          dataSet = JSON.parse(dataSet);\n          break;\n        case FLAG_NUMERIC:\n          dataSet = +dataSet;\n          break;\n        case FLAG_BINARY:\n          tmp = new Buffer(dataSet.length);\n          tmp.write(dataSet, 0, 'binary');\n          dataSet = tmp;\n          break;\n        }\n\n      // Add to queue as multiple get key key key key key returns multiple values\n      if (!multi) {\n        queue.push(dataSet);\n      } else {\n        multi[key] = dataSet;\n        if (cas) multi.cas = cas;\n        queue.push(multi);\n      }\n\n      return [BUFFER, false];\n    }\n\n  , 'INCRDECR': function incrdecr(tokens) {\n      return [CONTINUE, +tokens[1]];\n    }\n\n  , 'STAT': function stat(tokens, dataSet, err, queue) {\n      queue.push([tokens[1], /^\\d+$/.test(tokens[2]) ? +tokens[2] : tokens[2]]);\n      return [BUFFER, true];\n    }\n\n  , 'VERSION': function version(tokens, dataSet) {\n      var versionTokens = /(\\d+)(?:\\.)(\\d+)(?:\\.)(\\d+)$/.exec(tokens[1]);\n\n      return [CONTINUE, {\n        server: this.serverAddress\n      , version: versionTokens[0]\n      , major: versionTokens[1] || 0\n      , minor: versionTokens[2] || 0\n      , bugfix: versionTokens[3] || 0\n      }];\n    }\n\n  , 'ITEM': function item(tokens, dataSet, err, queue) {\n      queue.push({\n        key: tokens[1]\n      , b: +tokens[2].substr(1)\n      , s: +tokens[4]\n      });\n\n      return [BUFFER, false];\n    }\n    // Amazon-specific memcached configuration information, used for node\n    // auto-discovery.\n  , 'CONFIG': function() {\n      return [CONTINUE, this.bufferArray[0]];\n    }\n  };\n\n  function resultSetIsEmpty(resultSet) {\n    return !resultSet || (resultSet.length === 1 && !resultSet[0]);\n  }\n\n  // Parses down result sets\n  privates.resultParsers = {\n    // combines the stats array, in to an object\n    'stats': function stats(resultSet) {\n      var response = {};\n      if (resultSetIsEmpty(resultSet)) return response;\n\n      // add references to the retrieved server\n      response.server = this.serverAddress;\n\n      // Fill the object\n      resultSet.forEach(function each(statSet) {\n        if (statSet) response[statSet[0]] = statSet[1];\n      });\n\n      return response;\n    }\n\n    // the settings uses the same parse format as the regular stats\n  , 'stats settings': function settings() {\n      return privates.resultParsers.stats.apply(this, arguments);\n    }\n\n    // Group slabs by slab id\n  , 'stats slabs': function slabs(resultSet) {\n      var response = {};\n      if (resultSetIsEmpty(resultSet)) return response;\n\n      // add references to the retrieved server\n      response.server = this.serverAddress;\n\n      // Fill the object\n      resultSet.forEach(function each(statSet) {\n        if (statSet) {\n          var identifier = statSet[0].split(':');\n\n          if (!response[identifier[0]]) response[identifier[0]] = {};\n          response[identifier[0]][identifier[1]] = statSet[1];\n        }\n      });\n\n      return response;\n    }\n\n  , 'stats items': function items(resultSet) {\n      var response = {};\n      if (resultSetIsEmpty(resultSet)) return response;\n\n      // add references to the retrieved server\n      response.server = this.serverAddress;\n\n      // Fill the object\n      resultSet.forEach(function each(statSet) {\n        if (statSet && statSet.length > 1) {\n          var identifier = statSet[0].split(':');\n\n          if (!response[identifier[1]]) response[identifier[1]] = {};\n          response[identifier[1]][identifier[2]] = statSet[1];\n        }\n      });\n\n      return response;\n    }\n  };\n\n  // Generates a RegExp that can be used to check if a chunk is memcached response identifier\n  privates.allCommands = new RegExp('^(?:' + Object.keys(privates.parsers).join('|') + '|\\\\d' + ')');\n  privates.bufferedCommands = new RegExp('^(?:' + Object.keys(privates.parsers).join('|') + ')');\n\n  // When working with large chunks of responses, node chunks it in to pieces.\n  // So we might have half responses. So we are going to buffer up the buffer\n  // and user our buffered buffer to query // against. Also when you execute\n  // allot of .writes to the same stream, node will combine the responses in to\n  // one response stream. With no indication where it had cut the data. So it\n  // can be it cuts inside the value response, or even right in the middle of\n  // a line-break, so we need to make sure, the last piece in the buffer is\n  // a LINEBREAK because that is all what is sure about the Memcached Protocol,\n  // all responds end with them.\n  privates.buffer = function BufferBuffer(S, BufferStream) {\n    S.responseBuffer += BufferStream;\n\n    // only call transform the data once we are sure, 100% sure, that we valid\n    // response ending\n    if (S.responseBuffer.substr(S.responseBuffer.length - 2) === LINEBREAK) {\n      S.responseBuffer = Utils.reallocString(S.responseBuffer);\n\n      var chunks = S.responseBuffer.split(LINEBREAK);\n\n      if (this.debug) {\n        chunks.forEach(function each(line) {\n          console.log(S.streamID + ' >> ' + line);\n        });\n      }\n\n      // Fix zero-line endings in the middle\n      var chunkLength = (chunks.length-1);\n      if (chunks[chunkLength].length === 0) chunks.splice(chunkLength, 1);\n\n      S.responseBuffer = \"\"; // clear!\n      this.rawDataReceived(S, S.bufferArray = S.bufferArray.concat(chunks));\n    }\n  };\n\n  memcached.delegateCallback = function(){\n        this.activeQueries--;\n        var master = arguments[0];\n        var cb = arguments[arguments.length-1];\n        var args = Array.prototype.slice.call(arguments, 1, arguments.length-1);\n        cb.apply(master, args);\n  };\n\n  memcached.makeCallback = function(cb){\n       this.activeQueries--;\n       var args = Array.prototype.slice.call(arguments, 1);\n       cb.apply(this, args); //loose first\n  };\n\n  // The actual parsers function that scan over the responseBuffer in search of\n  // Memcached response identifiers. Once we have found one, we will send it to\n  // the dedicated parsers that will transform the data in a human readable\n  // format, deciding if we should queue it up, or send it to a callback fn.\n  memcached.rawDataReceived = function rawDataReceived(S) {\n    var queue = []\n      , token\n      , tokenSet\n      , dataSet\n      , resultSet\n      , metaData\n      , err = []\n      , tmp;\n\n    while(S.bufferArray.length && privates.allCommands.test(S.bufferArray[0])) {\n      token = S.bufferArray.shift();\n      tokenSet = token.split(' ');\n\n      if (/^\\d+$/.test(tokenSet[0])) {\n          // special case for \"config get cluster\"\n          // Amazon-specific memcached configuration information, see aws\n          // documentation regarding adding auto-discovery to your client library.\n          // Example response of a cache cluster containing three nodes:\n          //   configversion\\n\n          //   hostname|ip-address|port hostname|ip-address|port hostname|ip-address|port\\n\\r\\n\n          if (/(([-.a-zA-Z0-9]+)\\|(\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b)\\|(\\d+))/.test(S.bufferArray[0])) {\n              tokenSet.unshift('CONFIG');\n          }\n          // special case for digit only's these are responses from INCR and DECR\n          else {\n            tokenSet.unshift('INCRDECR');\n          }\n      }\n      // special case for value, it's required that it has a second response!\n      // add the token back, and wait for the next response, we might be\n      // handling a big ass response here.\n      if (tokenSet[0] === 'VALUE' && S.bufferArray.indexOf('END') === -1) {\n        return S.bufferArray.unshift(token);\n      }\n\n      // check for dedicated parser\n      if (privates.parsers[tokenSet[0]]) {\n\n        // fetch the response content\n        if (tokenSet[0] === 'VALUE') {\n          dataSet = Utils.unescapeValue(S.bufferArray.shift());\n        }\n\n        resultSet = privates.parsers[tokenSet[0]].call(S, tokenSet, dataSet || token, err, queue, this);\n\n        // check how we need to handle the resultSet response\n        switch (resultSet.shift()) {\n          case BUFFER:\n            break;\n\n          case FLUSH:\n            metaData = S.metaData.shift();\n            resultSet = queue;\n\n            // if we have a callback, call it\n            if (metaData && metaData.callback) {\n              metaData.execution = Date.now() - metaData.start;\n                this.delegateCallback(\n                  metaData\n                , err.length ? err : err[0]\n\n                  // see if optional parsing needs to be applied to make the result set more readable\n                , privates.resultParsers[metaData.type]\n                    ? privates.resultParsers[metaData.type].call(S, resultSet, err)\n                    : !Array.isArray(queue) || queue.length > 1 ? queue : queue[0]\n                ,metaData.callback\n              );\n            }\n\n            queue.length = err.length = 0;\n            break;\n\n          default:\n            metaData = S.metaData.shift();\n\n            if (metaData && metaData.callback) {\n              metaData.execution = Date.now() - metaData.start;\n              this.delegateCallback(metaData, err.length > 1 ? err : err[0], resultSet[0], metaData.callback);\n            }\n\n            err.length = 0;\n            break;\n        }\n      } else {\n        // handle unkown responses\n        metaData = S.metaData.shift();\n        if (metaData && metaData.callback){\n          metaData.execution = Date.now() - metaData.start;\n            this.delegateCallback(metaData, new Error('Unknown response from the memcached server: \"' + token + '\"'), false, metaData.callback);\n        }\n      }\n\n      // cleanup\n      dataSet = tokenSet = metaData = undefined;\n\n      // check if we need to remove an empty item from the array, as splitting on /r/n might cause an empty\n      // item at the end..\n      if (S.bufferArray[0] === '') S.bufferArray.shift();\n    }\n  };\n\n  // Small wrapper function that only executes errors when we have a callback\n  privates.errorResponse = function errorResponse(error, callback) {\n    if (typeof callback === 'function') {\n        memcached.makeCallback(callback,error, false);\n    }\n\n    return false;\n  };\n\n  // This is where the actual Memcached API layer begins:\n  memcached.touch = function touch(key, lifetime, callback) {\n    var fullkey = this.namespace + key;\n    this.command(function touchCommand() {\n      return {\n          key: fullkey\n        , callback: callback\n        , lifetime: lifetime\n        , validate: [['key', String], ['lifetime', Number], ['callback', Function]]\n        , type: 'touch'\n        , command: ['touch', fullkey, lifetime].join(' ')\n      };\n    });\n  };\n\n  memcached.get = function get(key, callback) {\n    if (Array.isArray(key)) return this.getMulti.apply(this, arguments);\n\n    var fullkey = this.namespace + key;\n    this.command(function getCommand(noreply) {\n      return {\n          key: fullkey\n        , callback: callback\n        , validate: [['key', String], ['callback', Function]]\n        , type: 'get'\n        , command: 'get ' + fullkey\n      };\n    });\n  };\n\n  // the difference between get and gets is that gets, also returns a cas value\n  // and gets doesn't support multi-gets at this moment.\n  memcached.gets = function get(key, callback) {\n    var fullkey = this.namespace + key;\n    this.command(function getCommand(noreply) {\n      return {\n          key: fullkey\n        , callback: callback\n        , validate: [['key', String], ['callback', Function]]\n        , type: 'gets'\n        , command: 'gets ' + fullkey\n      };\n    });\n  };\n\n  // Handles get's with multiple keys\n  memcached.getMulti = function getMulti(keys, callback) {\n    var memcached = this\n      , responses = {}\n      , errors = []\n      , calls;\n\n    if (memcached.namespace.length) keys = keys.map(function compile(key){\n      return memcached.namespace + key;\n    });\n\n    // handle multiple responses and cache them untill we receive all.\n    function handle(err, results) {\n      if (err) {\n        errors.push(err);\n      }\n\n      // add all responses to the array\n      (Array.isArray(results) ? results : [results]).forEach(function each(value) {\n        if (value && memcached.namespace.length) {\n          var ns_key = Object.keys(value)[0]\n            , newvalue = {};\n\n          newvalue[ns_key.replace(memcached.namespace, '')] = value[ns_key];\n          Utils.merge(responses, newvalue);\n        } else {\n          Utils.merge(responses, value);\n        }\n      });\n\n      if (!--calls){\n          callback(errors.length ? errors : undefined, responses);\n      }\n    }\n\n    this.multi(keys, function multi(server, key, index, totals) {\n      if (!calls) calls = totals;\n\n      memcached.command(function getMultiCommand(noreply) {\n        return {\n            callback: handle\n          , multi: true\n          , type: 'get'\n          , command: 'get ' + key.join(' ')\n          , key: keys\n          , validate: [['key', Array], ['callback', Function]]\n        };\n      }, server);\n    });\n  };\n\n  // As all command nearly use the same syntax we are going to proxy them all to\n  // this function to ease maintenance. This is possible because most set\n  // commands will use the same syntax for the Memcached server. Some commands\n  // do not require a lifetime and a flag, but the memcached server is smart\n  // enough to ignore those.\n  privates.setters = function setters(type, validate, key, value, lifetime, callback, cas) {\n    var fullkey = this.namespace + key;\n    var flag = 0\n      , valuetype = typeof value\n      , length;\n\n    if (Buffer.isBuffer(value)) {\n      flag = FLAG_BINARY;\n      value = value.toString('binary');\n    } else if (valuetype === 'number') {\n      flag = FLAG_NUMERIC;\n      value = value.toString();\n    } else if (valuetype !== 'string') {\n      flag = FLAG_JSON;\n      value = JSON.stringify(value);\n    }\n\n    value = Utils.escapeValue(value);\n\n    length = Buffer.byteLength(value);\n    if (length > this.maxValue) {\n      return privates.errorResponse(new Error('The length of the value is greater than ' + this.maxValue), callback);\n    }\n\n    this.command(function settersCommand(noreply) {\n      return {\n          key: fullkey\n        , callback: callback\n        , lifetime: lifetime\n        , value: value\n        , cas: cas\n        , validate: validate\n        , type: type\n        , redundancyEnabled: false\n        , command: [type, fullkey, flag, lifetime, length].join(' ') +\n               (cas ? ' ' + cas : '') +\n               (noreply ? NOREPLY : '') +\n               LINEBREAK + value\n      };\n    });\n  };\n\n  // Curry the function and so we can tell the type our private set function\n  memcached.set = curry(undefined, privates.setters\n    , 'set'\n    , [\n          ['key', String]\n        , ['value', String]\n        , ['lifetime', Number]\n        , ['callback', Function]\n      ]\n  );\n\n  memcached.replace = curry(undefined, privates.setters\n    , 'replace'\n    , [\n          ['key', String]\n        , ['value', String]\n        , ['lifetime', Number]\n        , ['callback', Function]\n      ]\n  );\n\n  memcached.add = curry(undefined, privates.setters\n    , 'add'\n    , [\n          ['key', String]\n        , ['value', String]\n        , ['lifetime', Number]\n        , ['callback', Function]\n      ]\n  );\n\n  memcached.cas = function checkandset(key, value, cas, lifetime, callback) {\n    privates.setters.call(this\n      , 'cas'\n      , [\n            ['key', String]\n          , ['value', String]\n          , ['lifetime', Number]\n          , ['callback', Function]\n        ]\n      , key\n      , value\n      , lifetime\n      , callback\n      , cas\n    );\n  };\n\n  memcached.append = function append(key, value, callback) {\n    privates.setters.call(this\n      , 'append'\n      , [\n            ['key', String]\n          , ['value', String]\n          , ['lifetime', Number]\n          , ['callback', Function]\n        ]\n      , key\n      , value\n      , 0\n      , callback\n    );\n  };\n\n  memcached.prepend = function prepend(key, value, callback) {\n    privates.setters.call(this\n      , 'prepend'\n      , [\n            ['key', String]\n          , ['value', String]\n          , ['lifetime', Number]\n          , ['callback', Function]\n        ]\n      , key\n      , value\n      , 0\n      , callback\n    );\n  };\n\n  // Small handler for incr and decr's\n  privates.incrdecr = function incrdecr(type, key, value, callback) {\n    var fullkey = this.namespace + key;\n    this.command(function incredecrCommand(noreply) {\n      return {\n          key: fullkey\n        , callback: callback\n        , value: value\n        , validate: [\n              ['key', String]\n            , ['value', Number]\n            , ['callback', Function]\n          ]\n        , type: type\n        , redundancyEnabled: true\n        , command: [type, fullkey, value].join(' ') +\n               (noreply ? NOREPLY : '')\n      };\n    });\n  };\n\n  // Curry the function and so we can tell the type our private incrdecr\n  memcached.increment = memcached.incr = curry(undefined, privates.incrdecr, 'incr');\n  memcached.decrement = memcached.decr = curry(undefined, privates.incrdecr, 'decr');\n\n  // Deletes the keys from the servers\n  memcached.del = function del(key, callback){\n    var fullkey = this.namespace + key;\n    this.command(function deleteCommand(noreply) {\n      return {\n          key: fullkey\n        , callback: callback\n        , validate: [\n              ['key', String]\n            , ['callback', Function]\n          ]\n        , type: 'delete'\n        , redundancyEnabled: true\n        , command: 'delete ' + fullkey +\n               (noreply ? NOREPLY : '')\n      };\n    });\n  };\n  memcached['delete'] = memcached.del;\n\n  // Small wrapper that handle single keyword commands such as FLUSH ALL, VERSION and STAT\n  privates.singles = function singles(type, callback) {\n    var memcached = this\n      , responses = []\n      , errors\n      , calls;\n\n      // handle multiple servers\n    function handle(err, results) {\n      if (err) {\n        errors = errors || [];\n        errors.push(err);\n      }\n      if (results) responses = responses.concat(results);\n\n      // multi calls should ALWAYS return an array!\n      if (!--calls) {\n          callback(errors && errors.length ? errors.pop() : undefined, responses);\n      }\n    }\n\n    this.multi(false, function multi(server, keys, index, totals) {\n      if (!calls) calls = totals;\n\n      memcached.command(function singlesCommand(noreply) {\n        return {\n            callback: handle\n          , type: type\n          , command: type\n        };\n      }, server);\n    });\n  };\n\n  // Curry the function and so we can tell the type our private singles\n  memcached.version  = curry(undefined, privates.singles, 'version');\n  memcached.flush = curry(undefined, privates.singles, 'flush_all');\n  memcached.stats = curry(undefined, privates.singles, 'stats');\n  memcached.settings = curry(undefined, privates.singles, 'stats settings');\n  memcached.slabs = curry(undefined, privates.singles, 'stats slabs');\n  memcached.items = curry(undefined, privates.singles, 'stats items');\n\n  // aliases\n  memcached.flushAll = memcached.flush;\n  memcached.statsSettings = memcached.settings;\n  memcached.statsSlabs = memcached.slabs;\n  memcached.statsItems = memcached.items;\n\n\n  // You need to use the items dump to get the correct server and slab settings\n  // see simple_cachedump.js for an example\n  memcached.cachedump = function cachedump(server, slabid, number, callback) {\n    this.command(function cachedumpCommand(noreply) {\n      return {\n          callback: callback\n        , number: number\n        , slabid: slabid\n        , validate: [\n              ['number', Number]\n            , ['slabid', Number]\n            , ['callback', Function]\n          ]\n        , type: 'stats cachedump'\n        , command: 'stats cachedump ' + slabid + ' ' + number\n      };\n    }, server);\n  };\n})(Client);\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-memcached/memcached/lib/connection.js":"\"use strict\";\n\nvar EventEmitter = require('events').EventEmitter\n  , spawn = require('child_process').spawn\n  , Utils = require('./utils')\n  , util = require('util');\n\nexports.IssueLog = IssueLog;         // connection issue handling\nexports.Available = ping;            // connection availablity\n\nfunction ping (host, callback) {\n  var isWin = process.platform.indexOf('win') === 0; // win32 or win64\n  var arg = isWin ? '-n' : '-c';\n  var pong = spawn('ping', [arg, '3', host]); // only ping 3 times\n\n  pong.stdout.on('data', function stdoutdata (data) {\n    callback(false, data.toString().split('\\n')[0].substr(14));\n    pong.kill();\n  });\n\n  pong.stderr.on('data', function stderrdata (data) {\n    callback(new Error(data.toString().split('\\n')[0].substr(14)), false);\n    pong.kill();\n  });\n}\n\nfunction IssueLog (args) {\n  this.config = args;\n  this.messages = [];\n  this.failed = false;\n  this.locked = false;\n  this.isScheduledToReconnect = false;\n\n  this.totalFailures = 0;\n  this.retry = 0;\n  this.totalReconnectsAttempted = 0;\n  this.totalReconnectsSuccess = 0;\n\n  Utils.merge(this, args);\n  EventEmitter.call(this);\n}\n\nutil.inherits(IssueLog, EventEmitter);\nvar issues = IssueLog.prototype;\n\nissues.log = function log (message) {\n  var issue = this;\n\n  this.failed = true;\n  this.messages.push(message || 'No message specified');\n\n  // All failures must occur within `failuresTimeout` ms from the initial\n  // failure in order for node to be disconnected or removed.\n  if (this.failures && this.failures == this.config.failures)\n    this.failuresResetId = setTimeout(issue.failuresReset.bind(issue), this.failuresTimeout);\n\n  if (this.failures && !this.locked) {\n    this.locked = true;\n    setTimeout(issue.attemptRetry.bind(issue), this.retry);\n    return this.emit('issue', this.details);\n  }\n\n  if (this.failuresResetId) clearTimeout(this.failuresResetId);\n\n  if (this.remove) return this.emit('remove', this.details);\n\n  if (!this.isScheduledToReconnect) {\n      this.isScheduledToReconnect = true;\n      setTimeout(issue.attemptReconnect.bind(issue), this.reconnect);\n  }\n};\n\nissues.failuresReset = function failuresReset() {\n  //this.failures = this.config.failures;\n  Utils.merge(this, JSON.parse(JSON.stringify(this.config)));\n};\n\nObject.defineProperty(issues, 'details', {\n  get: function getDetails () {\n    var res = {};\n\n    res.server = this.server;\n    res.tokens = this.tokens;\n    res.messages = this.messages;\n\n    if (this.failures) {\n      res.failures = this.failures;\n      res.totalFailures = this.totalFailures;\n    } else {\n      res.totalReconnectsAttempted = this.totalReconnectsAttempted;\n      res.totalReconnectsSuccess = this.totalReconnectsSuccess;\n      res.totalReconnectsFailed = this.totalReconnectsAttempted - this.totalReconnectsSuccess;\n      res.totalDownTime = (res.totalReconnectsFailed * this.reconnect) + (this.totalFailures * this.retry);\n    }\n\n    return res;\n  }\n});\n\nissues.attemptRetry = function attemptRetry () {\n  this.totalFailures++;\n  this.failures--;\n  this.failed = false;\n  this.locked = false;\n};\n\nissues.attemptReconnect = function attemptReconnect () {\n  var issue = this;\n  this.totalReconnectsAttempted++;\n  this.emit('reconnecting', this.details);\n\n  // Ping the server\n  ping(this.tokens[1], function pingpong (err) {\n    // still no access to the server\n    if (err) {\n      issue.messages.push(err.message || 'No message specified');\n      return setTimeout(issue.attemptReconnect.bind(issue), issue.reconnect);\n    }\n\n    issue.emit('reconnected', issue.details);\n\n    issue.totalReconnectsSuccess++;\n    issue.messages.length = 0;\n    issue.failed = false;\n    issue.isScheduledToReconnect = false;\n\n    // we connected again, so we are going through the whole cycle again\n    Utils.merge(issue, JSON.parse(JSON.stringify(issue.config)));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-memcached/memcached/lib/utils.js":"\"use strict\";\n\nvar createHash = require('crypto').createHash\n  , toString = Object.prototype.toString;\n\nexports.validateArg = function validateArg (args, config) {\n  var err;\n\n  args.validate.forEach(function (tokens) {\n    var key = tokens[0]\n      , value = args[key];\n\n    switch(tokens[1]){\n      case Number:\n        if (toString.call(value) !== '[object Number]') {\n          err = 'Argument \"' + key + '\" is not a valid Number.';\n        }\n\n        break;\n\n      case Boolean:\n        if (toString.call(value) !== '[object Boolean]') {\n          err = 'Argument \"' + key + '\" is not a valid Boolean.';\n        }\n\n        break;\n\n      case Array:\n        if (toString.call(value) !== '[object Array]') {\n          err = 'Argument \"' + key + '\" is not a valid Array.';\n        }\n        if (!err && key === 'key') {\n          for (var vKey=0; vKey<value.length; vKey++) {\n            var vValue = value[vKey];\n            var result = validateKeySize(config, vKey, vValue);\n            if (result.err) {\n              err = result.err;\n            } else {\n              args.command = args.command.replace(vValue, result['value']);\n            }\n          }\n        }\n        break;\n\n      case Object:\n        if (toString.call(value) !== '[object Object]') {\n          err = 'Argument \"' + key + '\" is not a valid Object.';\n        }\n\n        break;\n\n      case Function:\n        if (toString.call(value) !== '[object Function]') {\n          err = 'Argument \"' + key + '\" is not a valid Function.';\n        }\n\n        break;\n\n      case String:\n        if (toString.call(value) !== '[object String]') {\n          err = 'Argument \"' + key + '\" is not a valid String.';\n        }\n\n        if (!err && key === 'key') {\n          var result = validateKeySize(config, key, value);\n          if (result.err) {\n            err = result.err;\n          } else {\n            args.command = reallocString(args.command).replace(value, result['value']);\n          }\n        }\n        break;\n\n      default:\n        if (toString.call(value) === '[object global]' && !tokens[2]) {\n          err = 'Argument \"' + key + '\" is not defined.';\n        }\n    }\n  });\n\n  if (err){\n    if (args.callback) args.callback(new Error(err));\n    return false;\n  }\n\n  return true;\n};\n\nvar validateKeySize = function validateKeySize(config, key, value) {\n  if (value.length > config.maxKeySize) {\n    if (config.keyCompression){\n      return { err: false, value: createHash('md5').update(value).digest('hex') };\n    } else {\n      return { err: 'Argument \"' + key + '\" is longer than the maximum allowed length of ' + config.maxKeySize };\n    }\n  } else if (/[\\s\\n\\r]/.test(value)) {\n    return { err: 'The key should not contain any whitespace or new lines' };\n  } else {\n    return { err: false, value: value };\n  }\n};\n\n// a small util to use an object for eventEmitter\nexports.fuse = function fuse (target, handlers) {\n  for (var i in handlers)\n    if (handlers.hasOwnProperty(i)){\n      target.on(i, handlers[i]);\n    }\n};\n\n// merges a object's proppertys / values with a other object\nexports.merge = function merge (target, obj) {\n  for (var i in obj) {\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\n// curry/bind functions\nexports.curry = function curry (context, fn) {\n  var copy = Array.prototype.slice\n    , args = copy.call(arguments, 2);\n\n  return function bowlofcurry () {\n    return fn.apply(context || this, args.concat(copy.call(arguments)));\n  };\n};\n\n// a small items iterator\nexports.Iterator = function iterator (collection, callback) {\n  var arr = Array.isArray(collection)\n    , keys = !arr ? Object.keys(collection) : false\n    , index = 0\n    , maximum = arr ? collection.length : keys.length\n    , self = this;\n\n  // returns next item\n  this.next = function next () {\n    var obj = arr ? collection[index] : { key: keys[index], value: collection[keys[index]] };\n    callback(obj, index++, collection, self);\n  };\n\n  // check if we have more items\n  this.hasNext = function hasNext () {\n    return index < maximum;\n  };\n};\n\n//Escapes values by putting backslashes before line breaks\nexports.escapeValue = function(value) {\n  return value.replace(/(\\r|\\n)/g, '\\\\$1');\n};\n\n//Unescapes escaped values by removing backslashes before line breaks\nexports.unescapeValue = function(value) {\n  return value.replace(/\\\\(\\r|\\n)/g, '$1');\n};\n\nvar reallocString = exports.reallocString = function(value) {\n  // Reallocate string to fix slow string operations in node 0.10\n  // see https://code.google.com/p/v8/issues/detail?id=2869 for details\n  return (' ' + value).substr(1);\n};\n"}